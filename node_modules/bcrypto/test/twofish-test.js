'use strict';

const assert = require('bsert');
const Twofish = require('../lib/js/ciphers/twofish');
const cipher = require('../lib/cipher');

// https://github.com/golang/crypto/blob/master/twofish/twofish_test.go
// Format: [key, dec, enc].
const vectors = [
  // These tests are extracted from LibTom
  [
    Buffer.from([
      0x9f, 0x58, 0x9f, 0x5c, 0xf6, 0x12, 0x2c, 0x32, 0xb6, 0xbf, 0xec, 0x2f,
      0x2a, 0xe8, 0xc3, 0x5a
    ]),
    Buffer.from([
      0xd4, 0x91, 0xdb, 0x16, 0xe7, 0xb1, 0xc3, 0x9e, 0x86, 0xcb, 0x08, 0x6b,
      0x78, 0x9f, 0x54, 0x19
    ]),
    Buffer.from([
      0x01, 0x9f, 0x98, 0x09, 0xde, 0x17, 0x11, 0x85, 0x8f, 0xaa, 0xc3, 0xa3,
      0xba, 0x20, 0xfb, 0xc3
    ])
  ],
  [
    Buffer.from([
      0x88, 0xb2, 0xb2, 0x70, 0x6b, 0x10, 0x5e, 0x36, 0xb4, 0x46, 0xbb, 0x6d,
      0x73, 0x1a, 0x1e, 0x88, 0xef, 0xa7, 0x1f, 0x78, 0x89, 0x65, 0xbd, 0x44
    ]),
    Buffer.from([
      0x39, 0xda, 0x69, 0xd6, 0xba, 0x49, 0x97, 0xd5, 0x85, 0xb6, 0xdc, 0x07,
      0x3c, 0xa3, 0x41, 0xb2
    ]),
    Buffer.from([
      0x18, 0x2b, 0x02, 0xd8, 0x14, 0x97, 0xea, 0x45, 0xf9, 0xda, 0xac, 0xdc,
      0x29, 0x19, 0x3a, 0x65
    ])
  ],
  [
    Buffer.from([
      0xd4, 0x3b, 0xb7, 0x55, 0x6e, 0xa3, 0x2e, 0x46, 0xf2, 0xa2, 0x82, 0xb7,
      0xd4, 0x5b, 0x4e, 0x0d, 0x57, 0xff, 0x73, 0x9d, 0x4d, 0xc9, 0x2c, 0x1b,
      0xd7, 0xfc, 0x01, 0x70, 0x0c, 0xc8, 0x21, 0x6f
    ]),
    Buffer.from([
      0x90, 0xaf, 0xe9, 0x1b, 0xb2, 0x88, 0x54, 0x4f, 0x2c, 0x32, 0xdc, 0x23,
      0x9b, 0x26, 0x35, 0xe6
    ]),
    Buffer.from([
      0x6c, 0xb4, 0x56, 0x1c, 0x40, 0xbf, 0x0a, 0x97, 0x05, 0x93, 0x1c, 0xb6,
      0xd4, 0x08, 0xe7, 0xfa
    ])
  ],
  // These tests are derived from https://www.schneier.com/code/ecb_ival.txt
  [
    Buffer.from([
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00
    ]),
    Buffer.from([
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00
    ]),
    Buffer.from([
      0x9f, 0x58, 0x9f, 0x5c, 0xf6, 0x12, 0x2c, 0x32, 0xb6, 0xbf, 0xec, 0x2f,
      0x2a, 0xe8, 0xc3, 0x5a
    ])
  ],
  [
    Buffer.from([
      0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98,
      0x76, 0x54, 0x32, 0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77
    ]),
    Buffer.from([
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00
    ]),
    Buffer.from([
      0xcf, 0xd1, 0xd2, 0xe5, 0xa9, 0xbe, 0x9c, 0xdf, 0x50, 0x1f, 0x13, 0xb8,
      0x92, 0xbd, 0x22, 0x48
    ])
  ],
  [
    Buffer.from([
      0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98,
      0x76, 0x54, 0x32, 0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
      0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
    ]),
    Buffer.from([
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00
    ]),
    Buffer.from([
      0x37, 0x52, 0x7b, 0xe0, 0x05, 0x23, 0x34, 0xb8, 0x9f, 0x0c, 0xfc, 0xca,
      0xe8, 0x7c, 0xfa, 0x20
    ])
  ]
];

const mid = [
  Buffer.from('13da15275237fe6ebe7d93c8745c14fe', 'hex'),
  Buffer.from('cbfe324499b935323cbb648fc03fa27d', 'hex'),
  Buffer.from('5d8bc12464d707bbb86cd75d70c64852', 'hex'),
  Buffer.from('a1358fcad4902137792ace2b0f7cc26e', 'hex'),
  Buffer.from('a357c2e320ad6d3faef59a754cc17e18', 'hex'),
  Buffer.from('b074c6411f6fc42f06c50d86519db5f5', 'hex')
];

describe('Twofish', function() {
  for (const [i, [key, dec, enc]] of vectors.entries()) {
    it(`should pass twofish vector #${i}`, () => {
      const bits = key.length * 8;
      const c = new Twofish(bits).init(key);
      const buf = Buffer.alloc(16, 0x00);

      c.encrypt(buf, 0, dec, 0);
      assert.bufferEqual(buf, enc);

      c.decrypt(buf, 0, enc, 0);
      assert.bufferEqual(buf, dec);

      const zero = Buffer.alloc(16, 0x00);
      const data = Buffer.alloc(16, 0x00);

      for (let i = 0; i < 1000; i++)
        c.encrypt(data, 0, data, 0);

      assert.bufferEqual(data, mid[i]);

      for (let i = 0; i < 1000; i++)
        c.decrypt(data, 0, data, 0);

      assert.bufferEqual(data, zero);
    });

    it(`should pass twofish vector #${i} (cipher update)`, () => {
      const bits = key.length * 8;
      const c = new cipher.Cipher(`TWOFISH-${bits}-ECB`).init(key);
      const d = new cipher.Decipher(`TWOFISH-${bits}-ECB`).init(key);

      c.setAutoPadding(false);
      d.setAutoPadding(false);

      assert.bufferEqual(c.update(dec), enc);
      assert.bufferEqual(d.update(enc), dec);

      const zero = Buffer.alloc(16, 0x00);

      let data = Buffer.alloc(16, 0x00);

      for (let i = 0; i < 1000; i++)
        data = c.update(data);

      assert.bufferEqual(data, mid[i]);

      for (let i = 0; i < 1000; i++)
        data = d.update(data);

      assert.bufferEqual(data, zero);
    });

    it(`should pass twofish vector #${i} (cipher crypt)`, () => {
      const bits = key.length * 8;
      const c = new cipher.Cipher(`TWOFISH-${bits}`).init(key);
      const d = new cipher.Decipher(`TWOFISH-${bits}`).init(key);
      const buf = Buffer.alloc(16, 0x00);

      c.crypt(buf, dec);
      assert.bufferEqual(buf, enc);

      d.crypt(buf, enc);
      assert.bufferEqual(buf, dec);

      const zero = Buffer.alloc(16, 0x00);
      const data = Buffer.alloc(16, 0x00);

      for (let i = 0; i < 1000; i++)
        c.crypt(data, data);

      assert.bufferEqual(data, mid[i]);

      for (let i = 0; i < 1000; i++)
        d.crypt(data, data);

      assert.bufferEqual(data, zero);
    });
  }

  it('should encrypt & decrypt with twofish CBC', () => {
    const data = Buffer.alloc(16, 0x00);
    const key = Buffer.alloc(32, 0x00);
    const iv = Buffer.alloc(16, 0x00);

    const expect = Buffer.from(
      '57ff739d4dc92c1bd7fc01700cc8216fb07fb634f1e56d6d4c97aa3a791b3498',
      'hex'
    );

    const ct = cipher.encrypt('TWOFISH-256-CBC', key, iv, data);
    assert.bufferEqual(ct, expect);

    const pt = cipher.decrypt('TWOFISH-256-CBC', key, iv, ct);
    assert.bufferEqual(pt, data);
  });
});
